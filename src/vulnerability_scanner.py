import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime
import os
import re

class VulnerabilityScanner:
    def __init__(self):
        self.vulnerabilities = []
        self.nmap_path = self._find_nmap_path()
        print(f"üîß Using nmap from: {self.nmap_path}")
    
    def _find_nmap_path(self):
        """–ù–∞—Ö–æ–¥–∏–º –ø—É—Ç—å –∫ nmap"""
        possible_paths = ['/usr/bin/nmap', '/usr/local/bin/nmap', '/bin/nmap']
        for path in possible_paths:
            if os.path.exists(path):
                return path
        return 'nmap'
    
    def check_scripts_installed(self):
        """–ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –ª–∏ —Å–∫—Ä–∏–ø—Ç—ã —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π"""
        try:
            cmd = [self.nmap_path, '--script', 'vulners', '--script-help']
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if 'vulners' in result.stdout:
                print("‚úÖ Vulners script found!")
                return ['vulners']
            else:
                print("‚ö†Ô∏è Vulners script not found, using basic scanning")
                return []
                
        except Exception as e:
            print(f"‚ö†Ô∏è Script check failed: {e}")
            return []
    
    def scan_device_vulnerabilities(self, device_ip, device_info=None):
        """–£–ª—É—á—à–µ–Ω–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π —Å —É—á–µ—Ç–æ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ"""
        print(f"üîç Scanning {device_ip} for vulnerabilities...")
        
        try:
            vulnerabilities = []
            
            # –ú–µ—Ç–æ–¥ 1: –ü–æ–ª–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤
            vulns_method1 = self._full_port_scan(device_ip)
            vulnerabilities.extend(vulns_method1)
            
            # –ú–µ—Ç–æ–¥ 2: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –û–° –∏ —Å–µ—Ä–≤–∏—Å–æ–≤
            vulns_method2 = self._os_service_scan(device_ip, device_info)
            vulnerabilities.extend(vulns_method2)
            
            # –ú–µ—Ç–æ–¥ 3: –°–ø–µ—Ü–∏—Ñ–∏—á–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            vulns_method3 = self._targeted_scan_based_on_device(device_ip, device_info)
            vulnerabilities.extend(vulns_method3)
            
            print(f"‚úÖ Found {len(vulnerabilities)} potential issues for {device_ip}")
            return vulnerabilities
            
        except Exception as e:
            print(f"‚ùå Error scanning {device_ip}: {e}")
            return []
    
    def _full_port_scan(self, device_ip):
        """–ü–æ–ª–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π"""
        try:
            print(f"   üîé Full port scan for {device_ip}")
            
            # –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ—Ä—Ç—ã
            cmd_discovery = [
                self.nmap_path, '-sS', '-T4', '--open', 
                '-oX', '-', device_ip
            ]
            
            result = subprocess.run(cmd_discovery, capture_output=True, text=True, timeout=180)
            
            if result.returncode != 0:
                return []
            
            # –ü–∞—Ä—Å–∏–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ—Ä—Ç—ã
            open_ports = self._parse_open_ports(result.stdout)
            
            if not open_ports:
                print(f"   ‚ÑπÔ∏è No open ports found for {device_ip}")
                return []
            
            print(f"   üìç Found {len(open_ports)} open ports: {open_ports}")
            
            # –°–∫–∞–Ω–∏—Ä—É–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø–æ—Ä—Ç—ã –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
            port_arg = f"-p {','.join(open_ports)}"
            return self._scan_ports_with_vuln_scripts(device_ip, port_arg)
            
        except Exception as e:
            print(f"   ‚ùå Full port scan failed: {e}")
            return []
    
    def _parse_open_ports(self, xml_output):
        """–ü–∞—Ä—Å–∏–Ω–≥ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ—Ä—Ç–æ–≤ –∏–∑ XML"""
        try:
            root = ET.fromstring(xml_output)
            open_ports = []
            
            for host in root.findall('host'):
                for ports in host.findall('ports'):
                    for port in ports.findall('port'):
                        state = port.find('state')
                        if state is not None and state.get('state') == 'open':
                            open_ports.append(port.get('portid'))
            
            return open_ports
        except Exception as e:
            print(f"   ‚ùå Error parsing ports: {e}")
            return []
    
    def _scan_ports_with_vuln_scripts(self, device_ip, port_arg):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å–∫—Ä–∏–ø—Ç–æ–≤ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π"""
        try:
            vulnerabilities = []
            
            # –ë–∞–∑–æ–≤—ã–µ —Å–∫—Ä–∏–ø—Ç—ã –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—á—Ç–∏ –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–Ω—ã
            basic_security_scripts = [
                'banner', 'http-security-headers', 'ssh2-enum-algos',
                'ssl-enum-ciphers', 'ssl-cert', 'ftp-anon', 'smb-security-mode'
            ]
            
            cmd = [
                self.nmap_path, '-sV', port_arg,
                '--script', ','.join(basic_security_scripts),
                '-oX', '-', device_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            if result.returncode == 0:
                vulnerabilities.extend(self._parse_vulnerability_scan(result.stdout, device_ip))
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Vulnerability scan failed: {e}")
            return []
    
    def _os_service_scan(self, device_ip, device_info):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –û–° –∏ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        try:
            vulnerabilities = []
            
            # –ï—Å–ª–∏ –µ—Å—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–µ –¥–ª—è —Ü–µ–ª–µ–≤–æ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
            if device_info:
                print(f"   üîé OS-based scan for {device_ip} ({device_info.get('os', 'Unknown')})")
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —É—è–∑–≤–∏–º–æ—Å—Ç–∏ –û–°
                os_vulns = self._check_os_vulnerabilities(device_info)
                vulnerabilities.extend(os_vulns)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                device_type_vulns = self._check_device_type_vulnerabilities(device_info)
                vulnerabilities.extend(device_type_vulns)
            
            # –ë–∞–∑–æ–≤–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ä–≤–∏—Å–æ–≤
            cmd = [
                self.nmap_path, '-O', '-sV', '--version-intensity', '3',
                '-oX', '-', device_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
            
            if result.returncode == 0:
                vulnerabilities.extend(self._parse_os_service_scan(result.stdout, device_ip))
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå OS service scan failed: {e}")
            return []
    
    def _check_os_vulnerabilities(self, device_info):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –û–°"""
        vulnerabilities = []
        os_info = device_info.get('os', '').lower()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º Android
        if 'android' in os_info:
            vulnerabilities.append({
                'device_ip': device_info['ip'],
                'port': 'N/A',
                'service': 'Android OS',
                'version': self._extract_version(os_info),
                'description': 'Mobile devices may have unpatched vulnerabilities. Check for security updates.',
                'risk_level': 'MEDIUM',
                'script_used': 'OS Detection',
                'timestamp': datetime.now().isoformat()
            })
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º Linux
        elif 'linux' in os_info:
            vulnerabilities.append({
                'device_ip': device_info['ip'],
                'port': 'N/A',
                'service': 'Linux OS',
                'version': self._extract_version(os_info),
                'description': 'Ensure system is updated with latest security patches.',
                'risk_level': 'LOW',
                'script_used': 'OS Detection',
                'timestamp': datetime.now().isoformat()
            })
        
        return vulnerabilities
    
    def _extract_version(self, os_string):
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–∏ –∏–∑ —Å—Ç—Ä–æ–∫–∏ –û–°"""
        version_match = re.search(r'(\d+\.\d+(?:\.\d+)?)', os_string)
        return version_match.group(1) if version_match else 'Unknown'
    
    def _check_device_type_vulnerabilities(self, device_info):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
        vulnerabilities = []
        hardware_type = device_info.get('hardware', {}).get('type', '').lower()
        
        # IoT —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        if any(word in hardware_type for word in ['iot', 'raspberry', 'smart']):
            vulnerabilities.append({
                'device_ip': device_info['ip'],
                'port': 'N/A',
                'service': 'IoT Device',
                'version': '',
                'description': 'IoT devices often have default credentials and unpatched vulnerabilities.',
                'risk_level': 'HIGH',
                'script_used': 'Device Type Analysis',
                'timestamp': datetime.now().isoformat()
            })
        
        # –ú–æ–±–∏–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        elif any(word in hardware_type for word in ['mobile', 'phone', 'android', 'iphone']):
            vulnerabilities.append({
                'device_ip': device_info['ip'],
                'port': 'N/A',
                'service': 'Mobile Device',
                'version': '',
                'description': 'Mobile devices may have app vulnerabilities and weak security configurations.',
                'risk_level': 'MEDIUM',
                'script_used': 'Device Type Analysis',
                'timestamp': datetime.now().isoformat()
            })
        
        # –°–µ—Ç–µ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        elif any(word in hardware_type for word in ['router', 'gateway', 'switch']):
            vulnerabilities.append({
                'device_ip': device_info['ip'],
                'port': 'N/A',
                'service': 'Network Device',
                'version': '',
                'description': 'Network equipment often has web interfaces with default credentials.',
                'risk_level': 'HIGH',
                'script_used': 'Device Type Analysis',
                'timestamp': datetime.now().isoformat()
            })
        
        return vulnerabilities
    
    def _targeted_scan_based_on_device(self, device_ip, device_info):
        """–¶–µ–ª–µ–≤–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
        try:
            vulnerabilities = []
            
            if not device_info:
                return vulnerabilities
            
            hardware_type = device_info.get('hardware', {}).get('type', '').lower()
            hostname = device_info.get('hostname', '').lower()
            
            # –î–ª—è —Å–µ—Ç–µ–≤—ã—Ö —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã
            if any(word in hardware_type for word in ['router', 'gateway']) or 'router' in hostname:
                print(f"   üéØ Targeted router scan for {device_ip}")
                router_vulns = self._scan_router_services(device_ip)
                vulnerabilities.extend(router_vulns)
            
            # –î–ª—è Android —É—Å—Ç—Ä–æ–π—Å—Ç–≤
            elif 'android' in device_info.get('os', '').lower():
                print(f"   üì± Targeted Android scan for {device_ip}")
                android_vulns = self._scan_android_services(device_ip)
                vulnerabilities.extend(android_vulns)
            
            # –î–ª—è IoT —É—Å—Ç—Ä–æ–π—Å—Ç–≤
            elif any(word in hardware_type for word in ['iot', 'raspberry']):
                print(f"   üîå Targeted IoT scan for {device_ip}")
                iot_vulns = self._scan_iot_services(device_ip)
                vulnerabilities.extend(iot_vulns)
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Targeted scan failed: {e}")
            return []
    
    def _scan_router_services(self, device_ip):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–∏—á–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ —Ä–æ—É—Ç–µ—Ä–æ–≤"""
        try:
            common_router_ports = ['80', '443', '22', '23', '21', '53', '161', '8080', '8443']
            port_arg = f"-p {','.join(common_router_ports)}"
            
            cmd = [
                self.nmap_path, '-sV', port_arg,
                '--script', 'http-auth,http-title,ssh-auth-methods',
                '-oX', '-', device_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            vulnerabilities = []
            if result.returncode == 0:
                vulnerabilities.extend(self._parse_router_scan(result.stdout, device_ip))
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Router scan failed: {e}")
            return []
    
    def _parse_router_scan(self, xml_output, device_ip):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–æ—É—Ç–µ—Ä–∞"""
        vulnerabilities = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                for ports in host.findall('ports'):
                    for port in ports.findall('port'):
                        port_num = port.get('portid')
                        state = port.find('state')
                        
                        if state is not None and state.get('state') == 'open':
                            service = port.find('service')
                            service_name = service.get('name', 'unknown') if service else 'unknown'
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º HTTP —Å–µ—Ä–≤–∏—Å—ã
                            if service_name == 'http':
                                vulnerabilities.append({
                                    'device_ip': device_ip,
                                    'port': port_num,
                                    'service': service_name,
                                    'version': service.get('product', '') if service else '',
                                    'description': 'HTTP service detected - consider using HTTPS for encryption',
                                    'risk_level': 'MEDIUM',
                                    'script_used': 'Router Scan',
                                    'timestamp': datetime.now().isoformat()
                                })
                            
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º Telnet
                            elif service_name == 'telnet':
                                vulnerabilities.append({
                                    'device_ip': device_ip,
                                    'port': port_num,
                                    'service': service_name,
                                    'version': '',
                                    'description': 'Telnet service detected - unencrypted communication, serious security risk',
                                    'risk_level': 'HIGH',
                                    'script_used': 'Router Scan',
                                    'timestamp': datetime.now().isoformat()
                                })
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Error parsing router scan: {e}")
            return []
    
    def _scan_android_services(self, device_ip):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–∏—á–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ Android"""
        try:
            # Android —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –æ–±—ã—á–Ω–æ –∏–º–µ—é—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ—Ä—Ç—ã
            android_ports = ['5555', '5037', '8080', '9999']  # ADB, etc
            
            cmd = [
                self.nmap_path, '-sS', '-T4',
                '-p', ','.join(android_ports),
                '-oX', '-', device_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            vulnerabilities = []
            if result.returncode == 0:
                open_ports = self._parse_open_ports(result.stdout)
                
                if '5555' in open_ports:
                    vulnerabilities.append({
                        'device_ip': device_ip,
                        'port': '5555',
                        'service': 'adb',
                        'version': '',
                        'description': 'Android Debug Bridge (ADB) port open - potential security risk if exposed',
                        'risk_level': 'HIGH',
                        'script_used': 'Android Scan',
                        'timestamp': datetime.now().isoformat()
                    })
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Android scan failed: {e}")
            return []
    
    def _scan_iot_services(self, device_ip):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–∏—á–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ IoT —É—Å—Ç—Ä–æ–π—Å—Ç–≤"""
        try:
            iot_ports = ['80', '443', '22', '23', '1883', '8883', '5683']
            port_arg = f"-p {','.join(iot_ports)}"
            
            cmd = [
                self.nmap_path, '-sV', port_arg,
                '--script', 'banner,http-title',
                '-oX', '-', device_ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
            
            vulnerabilities = []
            if result.returncode == 0:
                vulnerabilities.extend(self._parse_iot_scan(result.stdout, device_ip))
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå IoT scan failed: {e}")
            return []
    
    def _parse_iot_scan(self, xml_output, device_ip):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è IoT"""
        vulnerabilities = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                for ports in host.findall('ports'):
                    for port in ports.findall('port'):
                        port_num = port.get('portid')
                        state = port.find('state')
                        
                        if state is not None and state.get('state') == 'open':
                            vulnerabilities.append({
                                'device_ip': device_ip,
                                'port': port_num,
                                'service': 'iot-service',
                                'version': '',
                                'description': f'IoT device has open port {port_num} - check for default credentials',
                                'risk_level': 'MEDIUM',
                                'script_used': 'IoT Scan',
                                'timestamp': datetime.now().isoformat()
                            })
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Error parsing IoT scan: {e}")
            return []
    
    def _parse_vulnerability_scan(self, xml_output, device_ip):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π"""
        vulnerabilities = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                for ports in host.findall('ports'):
                    for port in ports.findall('port'):
                        port_num = port.get('portid')
                        state = port.find('state')
                        
                        if state is not None and state.get('state') == 'open':
                            service = port.find('service')
                            service_name = service.get('name', 'unknown') if service else 'unknown'
                            
                            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–∫—Ä–∏–ø—Ç—ã
                            for script in port.findall('script'):
                                script_id = script.get('id')
                                output = script.get('output', '')
                                
                                vulnerability = self._analyze_script_findings(script_id, output, device_ip, port_num, service_name)
                                if vulnerability:
                                    vulnerabilities.append(vulnerability)
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Error parsing vulnerability scan: {e}")
            return []
    
    def _parse_os_service_scan(self, xml_output, device_ip):
        """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –û–° –∏ —Å–µ—Ä–≤–∏—Å–æ–≤"""
        vulnerabilities = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –û–°
                os_info = ''
                for os in host.findall('os'):
                    for osmatch in os.findall('osmatch'):
                        os_info = osmatch.get('name', '')
                        break
                
                if os_info:
                    vulnerabilities.append({
                        'device_ip': device_ip,
                        'port': 'N/A',
                        'service': 'Operating System',
                        'version': os_info,
                        'description': f'Detected OS: {os_info} - ensure latest security updates are installed',
                        'risk_level': 'LOW',
                        'script_used': 'OS Detection',
                        'timestamp': datetime.now().isoformat()
                    })
            
            return vulnerabilities
            
        except Exception as e:
            print(f"   ‚ùå Error parsing OS service scan: {e}")
            return []
    
    def _analyze_script_findings(self, script_id, output, device_ip, port, service):
        """–ê–Ω–∞–ª–∏–∑ –Ω–∞—Ö–æ–¥–æ–∫ —Å–∫—Ä–∏–ø—Ç–æ–≤"""
        output_lower = output.lower()
        
        if script_id == 'ssl-cert' and 'self signed' in output_lower:
            return {
                'device_ip': device_ip,
                'port': port,
                'service': service,
                'version': '',
                'description': f'Self-signed SSL certificate on port {port} - potential MITM risk',
                'risk_level': 'MEDIUM',
                'script_used': script_id,
                'timestamp': datetime.now().isoformat()
            }
        
        elif script_id == 'ssh2-enum-algos' and 'weak' in output_lower:
            return {
                'device_ip': device_ip,
                'port': port,
                'service': service,
                'version': '',
                'description': f'Weak SSH algorithms detected on port {port}',
                'risk_level': 'MEDIUM',
                'script_used': script_id,
                'timestamp': datetime.now().isoformat()
            }
        
        elif script_id == 'http-security-headers' and 'missing' in output_lower:
            return {
                'device_ip': device_ip,
                'port': port,
                'service': service,
                'version': '',
                'description': f'Missing security headers on HTTP service port {port}',
                'risk_level': 'LOW',
                'script_used': script_id,
                'timestamp': datetime.now().isoformat()
            }
        
        elif script_id == 'ftp-anon' and 'anonymous' in output_lower:
            return {
                'device_ip': device_ip,
                'port': port,
                'service': service,
                'version': '',
                'description': f'Anonymous FTP login allowed on port {port} - security risk',
                'risk_level': 'HIGH',
                'script_used': script_id,
                'timestamp': datetime.now().isoformat()
            }
        
        return None
    
    def generate_vulnerability_report(self, vulnerabilities):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –ø–æ —É—è–∑–≤–∏–º–æ—Å—Ç—è–º"""
        if not vulnerabilities:
            report = "‚úÖ No specific vulnerabilities found\n\n"
            report += "üí° Security Recommendations:\n"
            report += "‚Ä¢ Ensure all devices have latest security updates\n"
            report += "‚Ä¢ Change default credentials on network devices\n"
            report += "‚Ä¢ Use HTTPS instead of HTTP where possible\n"
            report += "‚Ä¢ Disable unused services and ports\n"
            report += "‚Ä¢ Regular security scanning recommended\n"
            return report
        
        report = "üõ°Ô∏è VULNERABILITY SCAN REPORT\n"
        report += "=" * 50 + "\n"
        report += f"üìÖ Scan time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += f"üîç Total findings: {len(vulnerabilities)}\n\n"
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —É—Ä–æ–≤–Ω—é —Ä–∏—Å–∫–∞
        high_risk = [v for v in vulnerabilities if v['risk_level'] == 'HIGH']
        medium_risk = [v for v in vulnerabilities if v['risk_level'] == 'MEDIUM']
        low_risk = [v for v in vulnerabilities if v['risk_level'] == 'LOW']
        
        if high_risk:
            report += "üö® HIGH RISK ISSUES:\n"
            report += "-" * 30 + "\n"
            for vuln in high_risk:
                report += f"‚Ä¢ {vuln['device_ip']}:{vuln['port']} - {vuln['description']}\n"
            report += "\n"
        
        if medium_risk:
            report += "‚ö†Ô∏è MEDIUM RISK ISSUES:\n"
            report += "-" * 30 + "\n"
            for vuln in medium_risk:
                report += f"‚Ä¢ {vuln['device_ip']}:{vuln['port']} - {vuln['description']}\n"
            report += "\n"
        
        if low_risk:
            report += "‚ÑπÔ∏è LOW RISK ISSUES:\n"
            report += "-" * 30 + "\n"
            for vuln in low_risk:
                report += f"‚Ä¢ {vuln['device_ip']}:{vuln['port']} - {vuln['description']}\n"
            report += "\n"
        
        report += "üí° Recommendations:\n"
        report += "‚Ä¢ Address HIGH risk issues immediately\n"
        report += "‚Ä¢ Schedule updates for MEDIUM risk items\n"
        report += "‚Ä¢ Monitor LOW risk items regularly\n"
        
        return report

    def get_installation_help(self):
        """–ò–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —É—Å—Ç–∞–Ω–æ–≤–∫–µ"""
        return """
üìã TO INSTALL VULNERABILITY SCRIPTS:

1. Install required packages:
   sudo apt update && sudo apt install nmap git wget

2. Install vulners script:
   sudo wget -O /usr/share/nmap/scripts/vulners.nse \\
   https://raw.githubusercontent.com/vulnersCom/nmap-vulners/master/vulners.nse

3. Install vulscan:
   sudo git clone https://github.com/scipag/vulscan.git \\
   /usr/share/nmap/scripts/vulscan
   sudo ln -s /usr/share/nmap/scripts/vulscan/vulscan.nse \\
   /usr/share/nmap/scripts/vulscan.nse

4. Update script database:
   sudo nmap --script-updatedb

5. Verify:
   nmap --script vulners --script-help
        """
