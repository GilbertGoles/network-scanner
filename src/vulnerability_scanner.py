import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime
import os
import re
import requests
import json
import sqlite3
from concurrent.futures import ThreadPoolExecutor

class AdvancedVulnerabilityScanner:
    def __init__(self):
        self.nmap_path = self._find_nmap_path()
        self.cve_database = self._load_cve_database()
        self.exploit_db = self._load_exploit_db()
        self.vulnerabilities = []
        print(f"üîß Advanced Vulnerability Scanner initialized")
    
    def _find_nmap_path(self):
        """–ù–∞—Ö–æ–¥–∏–º –ø—É—Ç—å –∫ nmap"""
        possible_paths = ['/usr/bin/nmap', '/usr/local/bin/nmap', '/bin/nmap']
        for path in possible_paths:
            if os.path.exists(path):
                return path
        return 'nmap'
    
    def _load_cve_database(self):
        """–ó–∞–≥—Ä—É–∑–∫–∞ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –±–∞–∑—ã CVE"""
        cve_db = {
            # –í–µ–±-—Å–µ—Ä–≤–µ—Ä—ã
            'apache': {
                '2.4.49': ['CVE-2021-41773', 'CVE-2021-42013'],
                '2.4.50': ['CVE-2021-41773', 'CVE-2021-42013'],
                '2.4.51': ['CVE-2021-44790']
            },
            'nginx': {
                '1.18.0': ['CVE-2021-23017'],
                '1.20.0': ['CVE-2021-23017']
            },
            
            # SSH
            'openssh': {
                '7.2': ['CVE-2016-6515', 'CVE-2016-10009'],
                '7.3': ['CVE-2016-10009'],
                '7.4': ['CVE-2017-15906'],
                '8.0': ['CVE-2019-16905']
            },
            
            # SMB
            'samba': {
                '4.0.0': ['CVE-2017-7494'],
                '4.5.0': ['CVE-2017-7494']
            },
            
            # RDP
            'rdp': {
                'all': ['CVE-2019-0708', 'CVE-2019-1181', 'CVE-2019-1182']
            },
            
            # FTP
            'vsftpd': {
                '2.3.4': ['CVE-2011-2523']
            },
            
            # Telnet
            'telnet': {
                'all': ['CVE-2020-10188', 'CVE-2021-28372']
            }
        }
        return cve_db
    
    def _load_exploit_db(self):
        """–ë–∞–∑–∞ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤"""
        return {
            'CVE-2017-0143': {
                'name': 'EternalBlue',
                'risk': 'CRITICAL',
                'description': 'SMBv1 Remote Code Execution',
                'port': '445',
                'exploit_available': True
            },
            'CVE-2019-0708': {
                'name': 'BlueKeep',
                'risk': 'CRITICAL', 
                'description': 'RDP Remote Code Execution',
                'port': '3389',
                'exploit_available': True
            },
            'CVE-2021-44228': {
                'name': 'Log4Shell',
                'risk': 'CRITICAL',
                'description': 'Log4j Remote Code Execution',
                'port': '80,443,8080,8443',
                'exploit_available': True
            },
            'CVE-2021-41773': {
                'name': 'Apache Path Traversal',
                'risk': 'HIGH',
                'description': 'Apache HTTP Server Path Traversal',
                'port': '80,443,8080',
                'exploit_available': True
            },
            'CVE-2011-2523': {
                'name': 'VSFTPD Backdoor',
                'risk': 'CRITICAL',
                'description': 'VSFTPD 2.3.4 Backdoor Command Execution',
                'port': '21',
                'exploit_available': True
            }
        }
    
    def scan_network_vulnerabilities(self, devices):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –≤—Å–µ–π —Å–µ—Ç–∏"""
        print("üîç –ó–∞–ø—É—Å–∫ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–≥–æ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π...")
        self.vulnerabilities = []
        
        with ThreadPoolExecutor(max_workers=3) as executor:
            results = list(executor.map(self.scan_device_vulnerabilities, devices))
        
        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        for device_vulns in results:
            self.vulnerabilities.extend(device_vulns)
        
        print(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π: {len(self.vulnerabilities)}")
        return self.vulnerabilities
    
    def scan_device_vulnerabilities(self, device):
        """–†–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞"""
        vulnerabilities = []
        ip = device['ip']
        
        print(f"üîç –°–∫–∞–Ω–∏—Ä—É—é —É—è–∑–≤–∏–º–æ—Å—Ç–∏: {ip} ({device['hostname']})")
        
        # –ú–µ—Ç–æ–¥ 1: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–µ—Ä—Å–∏–π —Å–µ—Ä–≤–∏—Å–æ–≤
        service_vulns = self._scan_service_versions(device)
        vulnerabilities.extend(service_vulns)
        
        # –ú–µ—Ç–æ–¥ 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —ç–∫—Å–ø–ª–æ–π—Ç–æ–≤
        exploit_vulns = self._check_known_exploits(device)
        vulnerabilities.extend(exploit_vulns)
        
        # –ú–µ—Ç–æ–¥ 3: –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å NSE —Å–∫—Ä–∏–ø—Ç–∞–º–∏
        nse_vulns = self._nmap_script_scan(device)
        vulnerabilities.extend(nse_vulns)
        
        # –ú–µ—Ç–æ–¥ 4: –≠–º—É–ª—è—Ü–∏—è –∞—Ç–∞–∫
        attack_vulns = self._simulate_attacks(device)
        vulnerabilities.extend(attack_vulns)
        
        return vulnerabilities
    
    def _scan_service_versions(self, device):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —É—è–∑–≤–∏–º—ã—Ö –≤–µ—Ä—Å–∏–π —Å–µ—Ä–≤–∏—Å–æ–≤"""
        vulnerabilities = []
        ip = device['ip']
        
        for service in device.get('services', []):
            service_name = service['name'].lower()
            version = service.get('version', '').lower()
            product = service.get('product', '').lower()
            
            # –ò—â–µ–º –≤ –±–∞–∑–µ CVE
            cve_list = self._find_cve_for_service(service_name, version, product)
            
            for cve_id in cve_list:
                exploit_info = self.exploit_db.get(cve_id, {})
                
                vulnerability = {
                    'device_ip': ip,
                    'device_hostname': device['hostname'],
                    'port': service['port'],
                    'service': service_name,
                    'version': version,
                    'cve_id': cve_id,
                    'name': exploit_info.get('name', 'Unknown'),
                    'description': exploit_info.get('description', 'Unknown vulnerability'),
                    'risk_level': exploit_info.get('risk', 'HIGH'),
                    'exploit_available': exploit_info.get('exploit_available', False),
                    'type': 'service_version',
                    'timestamp': datetime.now().isoformat()
                }
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    def _find_cve_for_service(self, service_name, version, product):
        """–ü–æ–∏—Å–∫ CVE –¥–ª—è —Å–µ—Ä–≤–∏—Å–∞"""
        cves = []
        
        # –ò—â–µ–º –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é —Å–µ—Ä–≤–∏—Å–∞
        if service_name in self.cve_database:
            for ver, cve_list in self.cve_database[service_name].items():
                if ver in version or ver == 'all':
                    cves.extend(cve_list)
        
        # –ò—â–µ–º –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –ø—Ä–æ–¥—É–∫—Ç–∞
        if product in self.cve_database:
            for ver, cve_list in self.cve_database[product].items():
                if ver in version or ver == 'all':
                    cves.extend(cve_list)
        
        return list(set(cves))  # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
    
    def _check_known_exploits(self, device):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ —ç–∫—Å–ø–ª–æ–π—Ç—ã"""
        vulnerabilities = []
        ip = device['ip']
        open_ports = [str(p['port']) for p in device.get('ports', [])]
        
        # EternalBlue (SMB)
        if '445' in open_ports:
            vulnerabilities.append({
                'device_ip': ip,
                'device_hostname': device['hostname'],
                'port': '445',
                'service': 'smb',
                'cve_id': 'CVE-2017-0143',
                'name': 'EternalBlue',
                'description': 'SMBv1 Remote Code Execution - CRITICAL RISK',
                'risk_level': 'CRITICAL',
                'exploit_available': True,
                'type': 'known_exploit',
                'timestamp': datetime.now().isoformat()
            })
        
        # BlueKeep (RDP)
        if '3389' in open_ports:
            vulnerabilities.append({
                'device_ip': ip,
                'device_hostname': device['hostname'],
                'port': '3389',
                'service': 'rdp',
                'cve_id': 'CVE-2019-0708',
                'name': 'BlueKeep',
                'description': 'RDP Remote Code Execution - CRITICAL RISK',
                'risk_level': 'CRITICAL',
                'exploit_available': True,
                'type': 'known_exploit',
                'timestamp': datetime.now().isoformat()
            })
        
        # Log4Shell (HTTP —Å–µ—Ä–≤–∏—Å—ã)
        http_ports = ['80', '443', '8080', '8443']
        if any(port in open_ports for port in http_ports):
            vulnerabilities.append({
                'device_ip': ip,
                'device_hostname': device['hostname'],
                'port': ','.join([p for p in http_ports if p in open_ports]),
                'service': 'http',
                'cve_id': 'CVE-2021-44228',
                'name': 'Log4Shell',
                'description': 'Log4j Remote Code Execution - CRITICAL RISK',
                'risk_level': 'CRITICAL',
                'exploit_available': True,
                'type': 'known_exploit',
                'timestamp': datetime.now().isoformat()
            })
        
        return vulnerabilities
    
    def _nmap_script_scan(self, device):
        """–°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é NSE —Å–∫—Ä–∏–ø—Ç–æ–≤"""
        vulnerabilities = []
        ip = device['ip']
        
        try:
            # –ó–∞–ø—É—Å–∫–∞–µ–º NSE —Å–∫—Ä–∏–ø—Ç—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π
            cmd = [
                self.nmap_path, '-sV', '--script', 
                'vuln,safe,ssh2-enum-algos,ssl-enum-ciphers,http-vuln*,smb-vuln*',
                '--script-args', 'unsafe=1',
                '-oX', '-', ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=180)
            
            if result.returncode == 0:
                nse_vulns = self._parse_nmap_nse_output(result.stdout, ip, device['hostname'])
                vulnerabilities.extend(nse_vulns)
            
        except Exception as e:
            print(f"‚ö†Ô∏è NSE scan failed for {ip}: {e}")
        
        return vulnerabilities
    
    def _parse_nmap_nse_output(self, xml_output, ip, hostname):
        """–ü–∞—Ä—Å–∏–Ω–≥ –≤—ã–≤–æ–¥–∞ NSE —Å–∫—Ä–∏–ø—Ç–æ–≤"""
        vulnerabilities = []
        
        try:
            root = ET.fromstring(xml_output)
            
            for host in root.findall('host'):
                for ports in host.findall('ports'):
                    for port in ports.findall('port'):
                        port_id = port.get('portid')
                        service = port.find('service')
                        service_name = service.get('name') if service is not None else 'unknown'
                        
                        # –ò—â–µ–º —Å–∫—Ä–∏–ø—Ç—ã —Å —É—è–∑–≤–∏–º–æ—Å—Ç—è–º–∏
                        for script in port.findall('script'):
                            script_id = script.get('id')
                            output = script.get('output', '')
                            
                            if any(keyword in script_id.lower() for keyword in ['vuln', 'exploit', 'vulnerability']):
                                vulnerability = {
                                    'device_ip': ip,
                                    'device_hostname': hostname,
                                    'port': port_id,
                                    'service': service_name,
                                    'cve_id': 'NSE-' + script_id,
                                    'name': f'NSE: {script_id}',
                                    'description': output[:500],  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–ª–∏–Ω—É
                                    'risk_level': 'MEDIUM',
                                    'exploit_available': False,
                                    'type': 'nse_script',
                                    'timestamp': datetime.now().isoformat()
                                }
                                vulnerabilities.append(vulnerability)
        
        except Exception as e:
            print(f"‚ö†Ô∏è NSE output parsing error: {e}")
        
        return vulnerabilities
    
    def _simulate_attacks(self, device):
        """–ò–º–∏—Ç–∞—Ü–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –∞—Ç–∞–∫ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞—â–∏—Ç—ã"""
        vulnerabilities = []
        ip = device['ip']
        
        print(f"üé≠ –ò–º–∏—Ç–∞—Ü–∏—è –∞—Ç–∞–∫ –Ω–∞ {ip}...")
        
        # SMB –∞—Ç–∞–∫–∞ (EternalBlue simulation)
        if self._simulate_smb_attack(ip):
            vulnerabilities.append({
                'device_ip': ip,
                'device_hostname': device['hostname'],
                'port': '445',
                'service': 'smb',
                'cve_id': 'SIM-SMB-001',
                'name': 'SMB Attack Simulation',
                'description': 'SMB service responded to attack simulation - may be vulnerable to EternalBlue',
                'risk_level': 'HIGH',
                'exploit_available': True,
                'type': 'attack_simulation',
                'timestamp': datetime.now().isoformat()
            })
        
        # HTTP –∞—Ç–∞–∫–∞ (Path Traversal)
        if self._simulate_http_attack(ip):
            vulnerabilities.append({
                'device_ip': ip,
                'device_hostname': device['hostname'],
                'port': '80,443,8080',
                'service': 'http',
                'cve_id': 'SIM-HTTP-001',
                'name': 'HTTP Path Traversal Simulation',
                'description': 'HTTP service vulnerable to path traversal attack simulation',
                'risk_level': 'HIGH',
                'exploit_available': True,
                'type': 'attack_simulation',
                'timestamp': datetime.now().isoformat()
            })
        
        # Telnet –∞—Ç–∞–∫–∞ (Brute Force simulation)
        if self._simulate_telnet_attack(ip):
            vulnerabilities.append({
                'device_ip': ip,
                'device_hostname': device['hostname'],
                'port': '23',
                'service': 'telnet',
                'cve_id': 'SIM-TELNET-001',
                'name': 'Telnet Attack Simulation',
                'description': 'Telnet service allows weak authentication',
                'risk_level': 'CRITICAL',
                'exploit_available': True,
                'type': 'attack_simulation',
                'timestamp': datetime.now().isoformat()
            })
        
        return vulnerabilities
    
    def _simulate_smb_attack(self, ip):
        """–ò–º–∏—Ç–∞—Ü–∏—è SMB –∞—Ç–∞–∫–∏"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–Ω–æ–Ω–∏–º–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ SMB
            cmd = [
                self.nmap_path, '--script', 'smb-enum-shares',
                '--script-args', 'smbusername=anonymous,smbpassword=anonymous',
                '-p', '445', ip
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            return 'anonymous' in result.stdout and 'ACCESS_READ' in result.stdout
            
        except:
            return False
    
    def _simulate_http_attack(self, ip):
        """–ò–º–∏—Ç–∞—Ü–∏—è HTTP –∞—Ç–∞–∫–∏"""
        try:
            import requests
            
            # –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –ø–æ—Ä—Ç—ã HTTP
            for port in [80, 443, 8080, 8443]:
                try:
                    protocol = 'https' if port in [443, 8443] else 'http'
                    url = f"{protocol}://{ip}:{port}/"
                    
                    # –¢–µ—Å—Ç path traversal
                    test_url = f"{url}../../../etc/passwd"
                    response = requests.get(test_url, timeout=5, verify=False)
                    
                    if 'root:' in response.text:
                        return True
                        
                except:
                    continue
                    
            return False
        except:
            return False
    
    def _simulate_telnet_attack(self, ip):
        """–ò–º–∏—Ç–∞—Ü–∏—è Telnet –∞—Ç–∞–∫–∏"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Telnet
            cmd = [self.nmap_path, '-p', '23', '--open', ip]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if '23/tcp open' in result.stdout:
                # Telnet –æ—Ç–∫—Ä—ã—Ç - —ç—Ç–æ —É–∂–µ —Ä–∏—Å–∫
                return True
                
            return False
        except:
            return False
    
    def generate_vulnerability_report(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç—á–µ—Ç–∞ –ø–æ —É—è–∑–≤–∏–º–æ—Å—Ç—è–º"""
        if not self.vulnerabilities:
            return "‚úÖ –£—è–∑–≤–∏–º–æ—Å—Ç–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
        
        report = "üî• –û–¢–ß–ï–¢ –û–ë –£–Ø–ó–í–ò–ú–û–°–¢–Ø–•\n"
        report += "=" * 60 + "\n\n"
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —É—Ä–æ–≤–Ω—é —Ä–∏—Å–∫–∞
        critical_vulns = [v for v in self.vulnerabilities if v['risk_level'] == 'CRITICAL']
        high_vulns = [v for v in self.vulnerabilities if v['risk_level'] == 'HIGH']
        medium_vulns = [v for v in self.vulnerabilities if v['risk_level'] == 'MEDIUM']
        
        if critical_vulns:
            report += "üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –£–Ø–ó–í–ò–ú–û–°–¢–ò:\n"
            report += "-" * 40 + "\n"
            for vuln in critical_vulns:
                report += f"‚Ä¢ {vuln['device_ip']}:{vuln['port']} - {vuln['name']}\n"
                report += f"  CVE: {vuln['cve_id']} | {vuln['description'][:100]}...\n"
                if vuln['exploit_available']:
                    report += f"  ‚ö†Ô∏è  EXPLOIT AVAILABLE!\n"
                report += "\n"
        
        if high_vulns:
            report += "üî¥ –í–´–°–û–ö–ò–ô –†–ò–°–ö:\n"
            report += "-" * 40 + "\n"
            for vuln in high_vulns:
                report += f"‚Ä¢ {vuln['device_ip']}:{vuln['port']} - {vuln['name']}\n"
                report += f"  CVE: {vuln['cve_id']} | {vuln['description'][:80]}...\n\n"
        
        if medium_vulns:
            report += "üü° –°–†–ï–î–ù–ò–ô –†–ò–°–ö:\n"
            report += "-" * 40 + "\n"
            for vuln in medium_vulns:
                report += f"‚Ä¢ {vuln['device_ip']}:{vuln['port']} - {vuln['name']}\n\n"
        
        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        report += "üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê:\n"
        report += f"‚Ä¢ –í—Å–µ–≥–æ —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π: {len(self.vulnerabilities)}\n"
        report += f"‚Ä¢ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö: {len(critical_vulns)}\n"
        report += f"‚Ä¢ –í—ã—Å–æ–∫–æ–≥–æ —Ä–∏—Å–∫–∞: {len(high_vulns)}\n"
        report += f"‚Ä¢ –°—Ä–µ–¥–Ω–µ–≥–æ —Ä–∏—Å–∫–∞: {len(medium_vulns)}\n"
        report += f"‚Ä¢ –° —ç–∫—Å–ø–ª–æ–π—Ç–∞–º–∏: {sum(1 for v in self.vulnerabilities if v['exploit_available'])}\n"
        
        return report
